# 3.3 Turning Commands into a Script

### **3.3 Turning Commands into a Script**

**Weight:** 4

**Description:** Turning repetitive commands into simple scripts.

**Key Knowledge Areas:**

* Basic shell scripting
* Awareness of common text editors (vi and nano)

**The following is a partial list of the used files, terms and utilities:**

* \#! (shebang)
* /bin/bash
* Variables
* Arguments
* for loops
* echo
* Exit status<br>

## Introduction to Linux Shell and Shell Scripting

Like any modern operating system linux involves interacting with a shell, which interprets and executes user commands. this interaction typically happens through the terminal, where users type commands for the shell to process.

Before learning shell scripting, you must understand:

* Kernel
* Shell
* Terminal

### Kernel <a href="#what-is-kernel" id="what-is-kernel"></a>

The kernel is a computer program that is the core of a computer's operating system, with complete control over everything in the system. It manages the following resources of the Linux system:

* File management
* Process management
* I/O management
* Memory management
* Device management etc.

> Complete Linux system = Kernel + GNUsystem utilities and libraries + other management scripts + installation scripts.

### **Shell** <a href="#what-is-shell" id="what-is-shell"></a>

A shell is a special user program that provides an interface for the user to use operating system services. Shell accepts human-readable commands from users and converts them into something which the kernel can understand. It is a command language interpreter that executes commands read from input devices such as keyboards or from files. The shell gets started when the user logs in or starts the terminal.

<figure><img src=".gitbook/assets/image (16).png" alt=""><figcaption></figcaption></figure>

Shell is broadly classified into two categories –

* Command Line Shell
* Graphical shell

{% hint style="success" %}
**Types of Shells:**

* **Bourne Shell (sh):** The original Unix shell, developed by Stephen Bourne.
* **C Shell (csh):** Known for its C-like syntax, popular for interactive use.
* **Korn Shell (ksh):** Combines features of sh and csh, offering advanced scripting capabilities.
* **Bash (Bourne Again SHell):** An improved version of sh, with additional features like command history and tab completion.



**Why Use Bash?**

* It is widely available on Unix/Linux systems, making scripts portable.
* Supports powerful scripting features, including loops, conditionals, and functions.
* Provides command history and tab completion for ease of use.
* Can be integrated with other Unix/Linux tools for automation.
{% endhint %}

### Terminal <a href="#what-is-a-terminal" id="what-is-a-terminal"></a>

A program which is responsible for providing an interface to a user so that he/she can access the shell. It basically allows users to enter commands and see the output of those commands in a text-based interface. Large scripts that are written to automate and perform complex tasks are executed in the terminal.  To access the terminal, simply search in search box "terminal" and double-click it.

<figure><img src=".gitbook/assets/image (18).png" alt=""><figcaption></figcaption></figure>

Before start writing our first hello world! shell script , we need to know about linux text editors.&#x20;

## Linux Text Editors

For Linux users, text editors are essential tools that play a crucial role in various tasks, from coding and writing to system administration and configuration management. Linux offers a wide range of text editors, catering to different preferences and use cases. In this article, we just have a quick look at vi (vim) , nano text editors.

### vi  <img src=".gitbook/assets/image (10).png" alt="" data-size="line"> <a href="#vi-text-editor" id="vi-text-editor"></a>

Vi (pronounced "vee-eye") is one of the oldest yet most popular text editors for Linux and Unix-based systems.

* It operates differently from modern editors because it uses multiple modes instead of direct typing.
* Vi does not rely on a mouse — all operations are performed using keyboard shortcuts.
* It is lightweight, fast, and available on almost all Unix and Linux systems by default.
* Though it may seem difficult for beginners, it becomes extremely efficient once learned.
* Many system administrators and developers prefer Vi for quick file edits directly from the terminal.
* It’s a reliable choice for working on remote servers or systems with minimal resources.

{% hint style="success" %}
### What is Vim? <a href="#what-is-vim" id="what-is-vim"></a>

Vim, short for Vi IMproved, is a highly configurable text editor built to enable efficient text editing. It’s an enhanced version of the Vi editor, which was developed back in the 1970s. Vim is widely used by programmers, system administrators, and anyone who spends a significant amount of time working in the terminal
{% endhint %}

Most Linux distributions come with Vim pre-installed. However, if it's not available on your system, you can install it using your package manager. For instance:

```
#Rocky
dnf install vim
```

```
#ubuntu
apt install vim
```

Now vim will be installed on your system. Let's Start to use Vim

### vim <img src=".gitbook/assets/image (11).png" alt="" data-size="line">

**You can open vim by running vim command on the terminal.**

```
vim
```

<figure><img src=".gitbook/assets/image (109).png" alt=""><figcaption></figcaption></figure>

#### Modes in Vim: <a href="#modes-in-vim" id="modes-in-vim"></a>

One of the unique features of Vim is its modes. Vim has several modes, each serving a different purpose:

1. **Normal Mode:** This is the default mode when you first open Vim. In this mode, you can navigate the file, delete text, copy text, and perform other commands.
2. **Insert Mode:** This mode allows you to insert and edit text. To enter Insert Mode from Normal Mode, press \`**`` i` ``**.
3. **Visual Mode:** In this mode, you can visually select blocks of text. To enter Visual Mode from Normal Mode, press **\``` v` ``**.
4. **Command-Line Mode:** This mode lets you enter Vim commands. To enter Command-Line Mode from Normal Mode, press \`**`` :` ``**.

<figure><img src=".gitbook/assets/image (110).png" alt="" width="563"><figcaption></figcaption></figure>



To open a file in vim editor just write the file name after the vim command in the terminal as follows:

```
vim filename.txt
```

Then the file will be opened.

**Write into file :**&#x20;

In the previous step we have opened the file now, Let's write some content in to write data we need to go in insert mode. To go into write mode type i. As follows:

```
i
```

After going into insert mode you will see **INSERT** in the status bar. After that, we can write any data in it.

<figure><img src=".gitbook/assets/image (111).png" alt=""><figcaption></figcaption></figure>

**Navigating in Vim:**

* **Moving the Cursor:** Use the arrow keys or \`**`` h` ``**, \`**`` j` ``**, \`**`` k` ``**, \`**`` l` ``** keys to move left, down, up, and right respectively.
* **Jumping to the Beginning or End of a Line:** Press \`**`` 0` ``** to jump to the beginning of a line and `$` to jump to the end.
* **Jumping to a Specific Line:** Type \`**`` :<line_number>` ``** and press Enter to jump to a specific line.

**text editing in vim:**

```
 i    ->   This key is used to put the cursor before the current position.
 a    ->   This key is used to put the cursor after the current position.
 o    ->   This key is used to put the cursor below the line.
 O    ->   This key is used to puts the cursor above the line.
```

**Save and Exit:**

We have written the data into a file now the task is to save and exit the file to do that first exit from insert mode by pressing the Esc key. To write a command first type semicolon  (  **:**  )  and then type the command wq!  or x! (both do the same thing) And then hit ENTER.

```
:wq!
```

<figure><img src=".gitbook/assets/image (112).png" alt=""><figcaption></figcaption></figure>

**Exit without saving the** **file:**

To exit from the file without saving the file just use the command q! As follows

```
:q!
```

> Vim also comes with its own tutorial. You can see this tutorial by command vimtutor into the terminal . `vimtutor`

### nano <img src=".gitbook/assets/image (12).png" alt="" data-size="line"> <a href="#nano-editor" id="nano-editor"></a>

Nano is a simple, lightweight, and user-friendly text editor used in Linux and other Unix-based systems.

* It offers a clean interface with on-screen keyboard shortcuts, making it easy to learn and use.
* Provides basic editing features such as cut, copy, paste, undo, redo, and search/replace.
* Supports syntax highlighting for various programming languages.
* Allows users to edit multiple files simultaneously using multiple buffers.
* Does not require switching modes like `vi` or `vim`, making it ideal for beginners.
* Common shortcuts are displayed at the bottom of the screen (e.g., `Ctrl + O` to save, `Ctrl + X` to exit).
* Suitable for both new users and experienced administrators who prefer quick edits in the terminal.

### Emacs <img src=".gitbook/assets/image (13).png" alt="" data-size="line">

GNU Emacs is a powerful and highly customizable text editor for Linux professionals created by Richard Stallman, the founder of the GNU project. It is designed to be versatile and has a wide range of built-in functions.

Emacs is used both as a command-line text editor and a GUI text editor. This dual functionality makes it suitable for many different users and use cases.&#x20;

### Gedit <img src=".gitbook/assets/image (14).png" alt="" data-size="line">

Gedit is a text editor that comes with the GNOME desktop environment. The design emphasizes simplicity, so Gedit is a great editor for beginners.&#x20;

***

## Getting Started with Shell Scripting <a href="#shell-scripting" id="shell-scripting"></a>

In the world of DevOps and system administration, automating repetitive tasks is key to saving time and reducing errors. That’s where shell scripting comes in. It allows you to write a series of commands in a file and run them all at once, just like a program. Whether it is setting up servers, managing files, or deploying code shell scripts make it fast, consistent, and effortless.

### Shell Script <a href="#what-is-shell-script" id="what-is-shell-script"></a>

A shell script is a file containing a series of commands for the shell to execute. The shell itself is a command-line interpreter (CLI), while a shell script is a saved list of instructions (usually with .sh extension) like myscript.sh.

```
vim myscript.sh
```

Our first Hello world! bash script:

```
#!/bin/sh
echo "Hello world!"
```

but wait , what is that first line?

### shebang <a href="#bd-shell" id="bd-shell"></a>

The most common need for using shebang appears when we’re writing shell scripts.

```
#!/bin/sh
echo "Hello world!"
```

The shebang is an interpreter directive used in Unix-like operating systems. It is a character sequence, #!, that constitutes the first line of a script. This line specifies the absolute path to the system interpreter (such as bash, python3, or perl) required to execute the commands within the script.

You will use a shebang to:

* Tell the system what language a script is in (e.t., bash, python3, node).
* Allow you to run a script directly (e.g., ./myscript.py) instead of typing the interpreter's name first (e.g., python3 myscript.py).
* Make your scripts portable so they work on other people's computers.

### How It Works: The Three Key Components <a href="#how-it-works-the-three-key-components" id="how-it-works-the-three-key-components"></a>

There are three distinct concepts that work together.

#### 1. The Shebang (#!) <a href="#id-1-the-shebang" id="id-1-the-shebang"></a>

The name "shebang" comes from its two characters:

* \#: The "hash" or "sharp" symbol.
* !: The "bang" or exclamation mark.

When you try to run a file, the Linux kernel opens it, sees the #! at the beginning, and knows it shouldn't run the file itself. Instead, it reads the rest of the line as a command to run, using the script as the input for that command.

#### 2. The Path <a href="#id-2-the-path" id="id-2-the-path"></a>

The path is the part after the #!.

```
#!/usr/bin/python3
```

* **What it does**: This directly tells the system to use the python3 program located in the /usr/bin folder.
* **Why it's bad**: What if another user's python3 is in /usr/local/bin/python3? The script will fail.

#### 3. The Executable Permission (chmod +x) <a href="#id-3-the-executable-permission-chmod-x" id="id-3-the-executable-permission-chmod-x"></a>

The shebang tells the system how to run the script, but the file's permissions tell the system if it's allowed to be run.

This is a separate and mandatory step.

* `chmod +x myscript.sh` grants executable permission.
* `chmod -x myscript.sh` removes executable permission.

and lets run our first Hello World! script:

```
[payam@earth Working]$ ./myscript.sh 
Hello world!
```

#### Comments in bash scripting <a href="#heading-comments-in-bash-scripting" id="heading-comments-in-bash-scripting"></a>

Comments start with a `#` in bash scripting. This means that any line that begins with a `#` is a comment and will be ignored by the interpreter.

Comments are very helpful in documenting the code, and it is a good practice to add them to help others understand the code.These are examples of comments:

```
# This is an example comment
# Both of these lines will be ignored by the interpreter
```

#### Variables and data types in Bash <a href="#heading-variables-and-data-types-in-bash" id="heading-variables-and-data-types-in-bash"></a>

Variables let you store data. You can use variables to read, access, and manipulate data throughout your script.

There are no data types in Bash. In Bash, a variable is capable of storing numeric values, individual characters, or strings of characters.

In Bash, you can use and set the variable values in the following ways:

1. Assign the value directly:

```
country=Iran
```

2. Assign the value based on the output obtained from a program or command, using command substitution. Note that `$` is required to access an existing variable's value.

```
same_country=$country
```

To access the variable value, append `$` to the variable name.

```
[payam@earth Working]$ country=iran
[payam@earth Working]$ echo $country 
iran
[payam@earth Working]$ new_country=$country
[payam@earth Working]$ echo $new_country 
iran
```

{% hint style="warning" %}
#### Variable naming conventions <a href="#heading-variable-naming-conventions" id="heading-variable-naming-conventions"></a>

In Bash scripting, the following are the variable naming conventions:

1. Variable names should start with a letter or an underscore (`_`).
2. Variable names can contain letters, numbers, and underscores (`_`).
3. Variable names are case-sensitive.
4. Variable names should not contain spaces or special characters.
5. Use descriptive names that reflect the purpose of the variable.
6. Avoid using reserved keywords, such as `if`, `then`, `else`, `fi`, and so on as variable names.

Here are some examples of valid variable names in Bash:

```bash
name
count
_var
myVar
MY_VAR
```

And here are some examples of invalid variable names:

```bash
2ndvar (variable name starts with a number)
my var (variable name contains a space)
my-var (variable name contains a hyphen)
```

Following these naming conventions helps make Bash scripts more readable and easier to maintain.
{% endhint %}

#### Input and output in Bash scripts <a href="#heading-input-and-output-in-bash-scripts" id="heading-input-and-output-in-bash-scripts"></a>

**Gathering input**

In this section, we'll discuss some methods to provide input to our scripts.

1. Reading the user input and storing it in a variable

We can read the user input using the `read` command.

```
#!/bin/bash 
echo "What's your name?" 
read entered_name 
echo -e "\nWelcome to bash tutorial" $entered_name
```

2. Reading from a file

This code reads each line from a file named `input.txt` and prints it to the terminal. We'll study while loops later in this article.

```
while read line
do
  echo $line
done < input.txt
```

3. Command line arguments

In a bash script or function, `$1` denotes the initial argument passed, `$2` denotes the second argument passed, and so forth.

This script takes a name as a command-line argument and prints a personalized greeting.

```
#!/bin/bash
echo "Hello, $1!"
```

#### arguments <a href="#heading-conditional-statements-ifelse" id="heading-conditional-statements-ifelse"></a>

One of the most essential aspects of Bash scripting is the ability to pass arguments to your scripts. This feature allows scripts to be flexible and dynamic, capable of handling various inputs and performing different actions based on those inputs.

When you pass arguments to a Bash script, they are stored in positional parameters, which are special variables:

* **$0** is the name of the script.
* **$1, $2,** and so on represent the arguments passed to the script.
* **$#** gives the number of arguments passed.
* **$@** and **$\*** represent all the arguments passed.

Let’s create an example script.

```bash
#!/bin/bash

echo "Script name: $0"
echo "First argument: $1"
echo "Second argument: $2"
echo "Total number of arguments: $#"
echo "All arguments: $@"
```

Now, we’ll run this script using the following arguments:

```bash
bash script.sh arg1 arg2
```

Output:

```bash
Script name: script.sh
First argument: arg1
Second argument: arg2
Total number of arguments: 2
All arguments: arg1 arg2
```

In this example, the script prints the script’s name, the first and second arguments, the total number of arguments, and all arguments as a list.

### Conditional statements (if/else) <a href="#heading-conditional-statements-ifelse" id="heading-conditional-statements-ifelse"></a>

Expressions that produce a boolean result, either true or false, are called conditions. There are several ways to evaluate conditions, including `if`, `if-else`, `if-elif-else`, and nested conditionals.

**Syntax**:

```bash
if [[ condition ]];
then
    statement
elif [[ condition ]]; then
    statement 
else
    do this by default
fi
```

Let's see an example of a Bash script that uses `if`, `if-else`, and `if-elif-else` statements to determine if a user-inputted number is positive, negative, or zero:

```
#!/bin/bash

echo "Please enter a number: "
read num

if [ $num -gt 0 ]; then
  echo "$num is positive"
elif [ $num -lt 0 ]; then
  echo "$num is negative"
else
  echo "$num is zero"
fi
```

The script first prompts the user to enter a number. Then, it uses an `if` statement to check if the number is greater than 0. If it is, the script outputs that the number is positive. If the number is not greater than 0, the script moves on to the next statement, which is an `if-elif` statement. Here, the script checks if the number is less than 0. If it is, the script outputs that the number is negative. Finally, if the number is neither greater than 0 nor less than 0, the script uses an `else` statement to output that the number is zero.

### Looping and Branching in Bash <a href="#heading-looping-and-branching-in-bash" id="heading-looping-and-branching-in-bash"></a>

#### While loop <a href="#heading-while-loop" id="heading-while-loop"></a>

While loops check for a condition and loop until the condition remains `true`. We need to provide a counter statement that increments the counter to control loop execution.

In the example below, `(( i += 1 ))` is the counter statement that increments the value of `i`. The loop will run exactly 10 times.

```bash
#!/bin/bash
i=1
while [[ $i -le 10 ]] ; do
   echo "$i"
  (( i += 1 ))
done
```

#### For loop <a href="#heading-for-loop" id="heading-for-loop"></a>

The `for` loop, just like the `while` loop, allows you to execute statements a specific number of times. Each loop differs in its syntax and usage.

In the example below, the loop will iterate 5 times.

```bash
#!/bin/bash

for i in {1..5}
do
    echo $i
done
```

#### Case statements <a href="#heading-case-statements" id="heading-case-statements"></a>

In Bash, case statements are used to compare a given value against a list of patterns and execute a block of code based on the first pattern that matches. The syntax for a case statement in Bash is as follows:

```bash
case expression in
    pattern1)
        # code to execute if expression matches pattern1
        ;;
    pattern2)
        # code to execute if expression matches pattern2
        ;;
    pattern3)
        # code to execute if expression matches pattern3
        ;;
    *)
        # code to execute if none of the above patterns match expression
        ;;
esac
```

Here, "expression" is the value that we want to compare, and "pattern1", "pattern2", "pattern3", and so on are the patterns that we want to compare it against.

The double semicolon ";;" separates each block of code to execute for each pattern. The asterisk "\*" represents the default case, which executes if none of the specified patterns match the expression.

Let's see an example.

```bash
fruit="apple"

case $fruit in
    "apple")
        echo "This is a red fruit."
        ;;
    "banana")
        echo "This is a yellow fruit."
        ;;
    "orange")
        echo "This is an orange fruit."
        ;;
    *)
        echo "Unknown fruit."
        ;;
esac
```

In this example, since the value of "fruit" is "apple", the first pattern matches, and the block of code that echoes "This is a red fruit." is executed. If the value of "fruit" were instead "banana", the second pattern would match and the block of code that echoes "This is a yellow fruit." would execute, and so on. If the value of "fruit" does not match any of the specified patterns, the default case is executed, which echoes "Unknown fruit."

**Check the exit code**

When Bash encounters an error, it sets an exit code that indicates the nature of the error. You can check the exit code of the most recent command using the `$?` variable. A value of `0` indicates success, while any other value indicates an error.

```
[payam@earth Working]$ echo $?
0
```

### Exist Status

Each Linux or Unix command returns a status when it terminates normally or abnormally. You can use value of exit status in the shell script to display an error message or run commands. For example, if tar command is unsuccessful, it returns a code which tells the shell script to send an e-mail to sysadmins.

You can use special shell variable called <kbd>$?</kbd> to get the exit status of the previously executed command.&#x20;

```
command
echo $?
```

{% hint style="info" %}
#### What is the $? (dollar question mark) in Bash?

The <kbd>$?</kbd> (dollar question mark) is the exit status of the last task or executed command by bash. It is a particular reserved shell variable that you can use to find out if your last executed command failed or not.
{% endhint %}

example:

```
[payam@earth Working]$ date
Mon Dec  8 12:56:18 PM +0330 2025
[payam@earth Working]$ echo $?
0
```

Notes:

1. The exit status is an integer number.
2. For the bash shell’s purposes, a command which exits with a zero (0) exit status has succeeded.
3. A non-zero (1-255) exit status indicates failure.
4. If a command is not found, the child process created to execute it returns a status of 127. If a command is found but is not executable, the return status is 126
5. All of the Bash builtins return exit status of zero if they succeed and a non-zero status on failure.

We can also store exit code for other perposes:

```
date
status=$?
echo "The date command exit status : ${status}"
```



That's all!

.

.

.

***

sources:

[https://www.geeksforgeeks.org/linux-unix/introduction-linux-shell-shell-scripting/](https://www.geeksforgeeks.org/linux-unix/introduction-linux-shell-shell-scripting/)\
[https://www.geeksforgeeks.org/linux-unix/using-shebang-in-linux/](https://www.geeksforgeeks.org/linux-unix/using-shebang-in-linux/)\
[https://www.geeksforgeeks.org/linux-unix/linux-text-editors/](https://www.geeksforgeeks.org/linux-unix/linux-text-editors/)\
[https://www.geeksforgeeks.org/linux-unix/basic-vi-commands/](https://www.geeksforgeeks.org/linux-unix/basic-vi-commands/)\
[https://www.geeksforgeeks.org/linux-unix/getting-started-with-vim-editor-in-linux/](https://www.geeksforgeeks.org/linux-unix/getting-started-with-vim-editor-in-linux/)\
[https://phoenixnap.com/kb/best-linux-text-editors-for-coding](https://phoenixnap.com/kb/best-linux-text-editors-for-coding)

[https://www.freecodecamp.org/news/bash-scripting-tutorial-linux-shell-script-and-command-line-for-beginners/](https://www.freecodecamp.org/news/bash-scripting-tutorial-linux-shell-script-and-command-line-for-beginners/)\
[https://www.freecodecamp.org/news/bash-scripting-tutorial-linux-shell-script-and-command-line-for-beginners/](https://www.freecodecamp.org/news/bash-scripting-tutorial-linux-shell-script-and-command-line-for-beginners/)\
[https://www.cyberciti.biz/faq/linux-bash-exit-status-set-exit-statusin-bash/](https://www.cyberciti.biz/faq/linux-bash-exit-status-set-exit-statusin-bash/)\
[https://www.atlantic.net/vps-hosting/passing-arguments-to-bash-scripts-a-practical-guide/](https://www.atlantic.net/vps-hosting/passing-arguments-to-bash-scripts-a-practical-guide/)
